<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[codeing中常用到的tips]]></title>
    <url>%2F2079%2F01%2F01%2F0809003%2F</url>
    <content type="text"><![CDATA[1. 获取json的key值 2. JS实时监听文本域的变化 3. JavaScript类型检验 1. 获取json的 key 值12var obj = &#123; name: "naruto", age: 23, dad: "minato"&#125;` 1.1. 使用 for in 来循环 :123for (var key in obj)&#123; console.log(key) // 依次输出 "name", "age", "dad"&#125; 这种方法比较常见，相信大家看到这个问题时第一时间都会想到吧，但是我要介绍的是下面这个更简单的方法。 1.2. 使用 Object.keys() 来获取 :12- console.log( Object.keys(obj) ) // 输出一个数组 [&quot;name&quot;, &quot;age&quot;, &quot;dad&quot;]- 所以, 当我们需要某个key值时可以从当前数组中取得。 2. JS实时监听文本域的变化众所周知，使用 onchange 事件来监听文本域的变化是我们在开发中用到的最多的方法。但是， onchange 是在文本域失焦时才触发，有时候由于需求的原因，需要我们来实时监听文本域的变化，除了使用keydown和keyup外，我们还可以: 2.1. 使用 onpropertychange12345&lt;input type="text" id="txt"&gt;$("#ysy").bind('input propertychange', function() &#123; console.log(new Date().getTime()); &#125;); 2.2 使用 oninput123document.getElementById('txt').oninput = function()&#123; console.log(this.value);&#125; 最后，总结一下onchange, onpropertychange和oninput之间的异同： onchange事件与onpropertychange事件的区别：onchange事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发；onpropertychange事件却是实时触发，即每增加或删除一个字符就会触发，通过js改变也会触发该事件，但是该事件IE专有。 oninput事件与onpropertychange事件的区别：oninput事件是IE之外的大多数浏览器支持的事件，在value改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过js改变value时，却不会触发；onpropertychange事件是任何属性改变都会触发的，而oninput却只在value改变时触发，oninput要通过addEventListener()来注册，onpropertychange注册方式跟一般事件一样。（此处都是指在js中动态绑定事件，以实现内容与行为分离）&gt; oninput与onpropertychange失效的情况： （1）oninput事件：a). 当脚本中改变value时，不会触发；b).从浏览器的自动下拉提示中选取时，不会触发。 （2）onpropertychange事件：当input设置为disable=true后，onpropertychange不会触发。 3. JavaScript类型检验一个简单有用的js类型检验的方法123456789101112function checkType(sth) &#123; return Object.prototype.toString.call(o) .match(/(\w+)\]$/)[1] .toLowerCase();&#125;checkType(&#123;&#125;) // objectcheckType([]) // arraycheckType(function()&#123;&#125;) // functioncheckType(1) // numbercheckType(+'3') // numbercheckType(3+'') // string]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>other</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的markdown语法]]></title>
    <url>%2F2018%2F03%2F02%2F0809013%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常用的Vim命令]]></title>
    <url>%2F2018%2F03%2F02%2F0809012%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常用的GIT命令]]></title>
    <url>%2F2018%2F03%2F02%2F0809011%2F</url>
    <content type="text"></content>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小窥Node.js服务端框架Express]]></title>
    <url>%2F2018%2F03%2F02%2F0809010%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli快速构建vue.js项目]]></title>
    <url>%2F2018%2F03%2F01%2F0809009%2F</url>
    <content type="text"><![CDATA[快速上手 构建命令 配置Babel 1. 快速上手本文介绍如何使用vue-cli快速构建vus.js项目，主要用到webpack，以及vue-loader，所以确保你的环境中安装有webpack。 123456789101112131415# 安装vue-cli脚手架工具$ npm install -g vue-cli# 在 my-project 目录中生成一个项目# 这一步中你还可以选择是否安装vue-router,ESLint,unit tests, e2e tests...$ vue init webpack my-project# 进入到项目$ cd my-project# 安装依赖$ npm install# 构建并启动项目$ npm run dev 如果你在 vue init webpack my-project 步骤中选择安装所有的工具，那么我们的项目目录结构应该是这样的：123456789101112131415161718192021222324252627282930313233343536.├── build/ # webpack config files│ └── ...├── config/│ ├── index.js # main project config│ └── ...├── src/│ ├── main.js # app entry file│ ├── App.vue # main app component│ ├── components/ # ui components│ │ └── ...│ └── assets/ # module assets (processed by webpack)│ └── ...├── static/ # pure static assets (directly copied)├── test/│ └── unit/ # unit tests│ │ ├── specs/ # test spec files│ │ ├── eslintrc # config file for eslint with extra settings only for unit tests│ │ ├── index.js # test build entry file│ │ ├── jest.conf.js # Config file when using Jest for unit tests│ │ └── karma.conf.js # test runner config file when using Karma for unit tests│ │ ├── setup.js # file that runs before Jest runs your unit tests│ └── e2e/ # e2e tests│ │ ├── specs/ # test spec files│ │ ├── custom-assertions/ # custom assertions for e2e tests│ │ ├── runner.js # test runner script│ │ └── nightwatch.conf.js # test runner config file├── .babelrc # babel config├── .editorconfig # indentation, spaces/tabs and similar settings for your editor├── .eslintrc.js # eslint config├── .eslintignore # eslint ignore rules├── .gitignore # sensible defaults for gitignore├── .postcssrc.js # postcss config├── index.html # index.html template├── package.json # build scripts and dependencies└── README.md # Default README file 目录/文件介绍： build/：该目录保存的是开发和生产环境中的webpack配置，一般情况下是不需要进行修改的；当需要自定义webpack配置时，可以从webpack.base.conf.js开始研究。 config/index.js：这是项目构建时需要的一些最常用到的配置文件。 src/：这里存放的就是我们的业务代码了，我们可以根据项目需要自行配置。 static/：在这里，我们可以存放一些我们不希望webpack来处理的静态资源文件，在使用webpack来构建时，这里的文件将会直接复制到构建后的资源目录下。 test/unit：单元测试相关文件。 test/e2e：e2e测试相关文件。 index.html：基于vue.js的SPA单页应用的入口HTML模板，在开发、构建过程中，webpack将生成很多资源文件，文件之间的URL会被自动的注入到该index.html中。 package.json：npm包源文件，包含所有的构建依赖和构建命令。 2. 构建命令所有的构建命令都是通过npm脚本执行的，见package.json//scripts。 1npm run dev 在本地开发环境启动一个node.js服务器。 webpack + vue-loader 作用于vue的单文件组件 状态保存，热加载 使用ESLint检查js 生成资源文件的sourcemap …… 1npm run build 在生产环境中构建资源 使用UglifyJS v3压缩JavaScript 使用html-minifier压缩HTML 使用cssnano将所有组件的CSS提取到一个文件中 使用版本哈希编译所有的静态文件，以实现资源的持久缓存。为所有的资源自定生成合适的URL，最后注入到index.html中，完成整个工程的构建。 1npm run unit 使用Jest在JSDOM中运行单元测试 1npm run lint 运行ESLint并报告任何linting错误。 更多构建命令请查阅相关资料 3. 配置Babel 详见我的另外一篇文章 至此，通过vue-cli构建vue工程的基本过程已经结束，查看更多详细配置，请转]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue.js</tag>
        <tag>webpack</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次在公司中配置Babel的经历]]></title>
    <url>%2F2018%2F03%2F01%2F0809007%2F</url>
    <content type="text"><![CDATA[安装 使用 创建.babelrc文件 Babel-Polyfill Babel-Register &emsp;首先，为什么会写这样一篇文章呢？在进入公司几个月后，写业务代码都是使用es5语法，es6，于是想着使用Babel来构建一下。这样既可以愉快的使用ES6了，还能舒心的写代码，何乐而不为。 Babel的使用是基于Node.js环境的，所以必须先安装Node。 我们将采用通过安装babel-cli的方式来使用babel。 1. 安装&emsp;虽然你可以在你的机器上全局安装Babel CLI, 但根据单个项目进行本地安装会更好一些。这样做有两个主要的原因： 同一机器上的不同的项目可以依赖不同版本的 Babel, 这允许你一次更新一个项目。 这意味着在你的工作环境中没有隐含的依赖项。它将使你的项目更方便移植、更易于安装。 首先我们需要生成一个package.json文件，进入到项目目录执行npm init命令，随后一顿选择回车。 12345678910111213YSY@SY-YU MINGW64 /d/START/webpack$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (webpack) 最后，目录下会生成一个package.json文件，打开看一下1234567891011&#123; "name": "webpack", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "yvshare.cn", "license": "ISC"&#125; 里面都是刚才npm init时自己的配置 我们可以通过以下命令本地安装 Babel CLI: 1234// 全局安装npm install babel-cli -g// 安装在当前项目中npm install --save-dev babel-cli 我们在当前目录安装babel-cli，随后我们的package.json应该长这个样：1234567891011121314&#123; "name": "webpack", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "yvshare.cn", "license": "ISC", "devDependencies": &#123; "babel-cli": "^6.26.0" &#125;&#125; 2. 使用 我们将把我们的指令放在本地版本的 npm 脚本中，而不是直接通过命令行来运行 Babel. 简单的在你的 package.json 中添加一个 “scripts” 属性并将 babel 命令放在它的 build 属性中： 1234567891011 &#123; "name": "webpack", "version": "1.0.0", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",+ "build": "babel src -d lib" // 加入这一句命令 &#125;, "devDependencies": &#123; "babel-cli": "^6.26.0" &#125; &#125; 现在从我们的终端可以运行以下命令：1npm run build 这会按照和之前一样的方式来运行 Babel 并将输出放在 lib 目录下，唯一不同在于我们现在使用了一个本地拷贝。 值得注意的是在babel的build命令是可以在build属性中自行配置的，上面是把src目录下的脚本打包到lib目录中，你也可以打包单个文件… 3. 创建.babelrc配置文件 虽然已经配置好了 Babel ，但并没有让它真正生效。在项目的根目录中创建一个 .babelrc 文件并启用一些插件。 详看 首先，你可以使用转换 ES2015+ 的 env preset：1npm install babel-preset-env --save-dev 为了让 preset 生效，你需要像下面这样定义你的 .babelrc 文件：1234&#123; "presets": ["env"], "plugins": []&#125; .babelrc配置文件非常丰富： 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 最后，我们的 .babelrc 文件可以长这个样：12345678&#123; "presets": [ "es2015", "react", "stage-2" ], "plugins": []&#125; 4. Babel-PolyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下：1npm install --save babel-polyfill 然后，在脚本头部，加入如下一行代码：123import 'babel-polyfill';// 或者require('babel-polyfill'); 5. Babel-Registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。1npm install --save-dev babel-register 使用时，必须首先加载babel-register：12import("babel-register");import("./index.js"); 然后，就不需要手动对index.js转码了。 需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 后记：虽然实际项目上的配置根据实际情况有所不同，但是基本的东西就是这个样子了，以后有类似需求就可以根据文档来进行了，非常方便。 参考文档： babeljs.cn / ruanyifeng.com]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>es6</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON 序列化选项]]></title>
    <url>%2F2018%2F02%2F27%2F0809005%2F</url>
    <content type="text"><![CDATA[实际上，JSON.stringify()除了要序列化JavaScript对象外，还可以接受另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象。第一个参数是个过滤器，可以使一个数组，也可以是个函数；第二个参数是一个选项，表示是否在JSON字符串中保留缩进。单独或组合使用者两个参数，可以更全面深入地控制JSON的序列化。 1. 过滤器（第一个参数）1.数组12345678910var hero = &#123; "name": "MasterYi", "skills": [ "AlphaStrike" ], "type": "Warrior"&#125;var jsonTxt = JSON.stringify(hero, ["name", "type"]);jsonTxt --&gt; "&#123;"name":"MasterYi","type":"Warrior"&#125;" 2.函数1234567891011var jsonTxt = JSON.stringify(hero, function(k, v)&#123; switch(k)&#123; case "name": return "Annie"; case "type": return "Mage"; default: return v; &#125;&#125;);jsonTxt --&gt; "&#123;"name":"Annie","skills":["AlphaStrike"],"type":"Mage"&#125;" 值得注意的是，如果函数返回了undefined，那么相应的属性会被忽略。另外请务必写上default，此时返回传入的值，以便其他值都能正常出现在结果中 2. 选项（字符串缩进）12345678910111213141516171819var jsonTxt1 = JSON.stringify(hero, null, 2);jsonTxt1 --&gt;"&#123; "name": "MasterYi", "skills": [ "AlphaStrike" ], "type": "Warrior"&#125;"var jsonTxt2 = JSON.stringify(hero, null, 4);jsonTxt2 --&gt;"&#123; "name": "MasterYi", "skills": [ "AlphaStrike" ], "type": "Warrior"&#125;" 如上，结果字符串中也插入了换行符，这样一来就提高了可读性。只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。最大缩进空格数为10，大于10会默认转换为10.]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 渐变]]></title>
    <url>%2F2018%2F02%2F27%2F0809002%2F</url>
    <content type="text"><![CDATA[CSS3 定义了两种类型的渐变（gradients）： 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义注意： IE 9 及之前的版本不支持渐变。线性渐变： background: linear-gradient(direction, color-stop1, color-stop2, ...);1. 线性渐变 - 从上到下（默认情况下）:123456.box &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法(必须放在最后) */&#125; 效果图 2. 线性渐变 - 从左到右1234567.box &#123; height: 50px; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法（必须放在最后） */&#125; 效果图 3. 重复的线性渐变12345678.box &#123; height: 100px; width: 100px; background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Safari 5.1 - 6.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法（必须放在最后） */&#125; 效果图 4. 线性渐变进阶12345678.box&#123; height: 100px; width: 100px; background: -webkit-linear-gradient(0deg,#FF0000 0%,#00FF00 50%,#0000FF 100%); background: -o-linear-gradient(0deg,#FF0000 0%,#00FF00 50%,#0000FF 100%); background: -moz-linear-gradient(0deg,#FF0000 0%,#00FF00 50%,#0000FF 100%); background: linear-gradient(0deg,#FF0000 0%,#00FF00 50%,#0000FF 100%);&#125; 效果图 没错，就是通过角度来空值渐变的起始位置： 45deg 效果图 90deg 效果图 135deg 效果图 由此，我们知道了起始可以通过角度来获得我们想要的线性渐变的各种效果了，这基本能满足我们大多数的需求了。径向渐变 background: radial-gradient(center, shape size, start-color, ..., last-color); 径向渐变由它的中心定义。 为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（原型或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。1. 普通的径向渐变12345678.box &#123; height: 100px; width: 100px; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法（必须放在最后） */&#125; 效果图 2. 不均匀的径向渐变123456.box &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */&#125; 效果图 径向渐变容器如果不为正方形，则渐变区域会默认呈现为椭圆，若为正方形，则会呈现为正方形。 3.不同尺寸的径向渐变 closest-side farthest-side closest-corner farthest-corner 123456.box &#123; background: -webkit-radial-gradient(70% 50%, closest-side,red,green,blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(70% 50%, closest-side,red,green,blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(70% 50%, closest-side,red,green,blue); /* Firefox 3.6 - 15 */ background: radial-gradient(70% 50%, closest-side,red,green,blue); /* 标准的语法（必须放在最后） */&#125; 效果图 从上面的效果图中可以看出径向渐变的渐变原点的作用 通过设置尺寸属性可以改变其大小4.重复的径向渐变12345678.box &#123; height: 100px; width: 100px; background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%); /* Safari 5.1 - 6.0 */ background: -o-repeating-radial-gradient(red, yellow 10%, green 15%); /* Opera 11.6 - 12.0 */ background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%); /* Firefox 3.6 - 15 */ background: repeating-radial-gradient(red, yellow 10%, green 15%); /* 标准的语法（必须放在最后） */&#125; 效果图]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5存储webStorage]]></title>
    <url>%2F2018%2F02%2F27%2F0809004%2F</url>
    <content type="text"><![CDATA[客户端存储数据的两个对象为： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session(会话) 的数据存储 在使用 web 存储前，应检查浏览器是否支持 localStorage 和sessionStorage : 1234567if( typeof(Storage) !== &quot;undefined&quot; )&#123; // 是的! 支持 localStorage sessionStorage 对象! // your code&#125; else &#123; // 抱歉! 不支持 web 存储。&#125; 1. localStorage 对象 localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 实例： 12localStorage.name=&quot;yasuo&quot;;document.getElementById(&quot;hero&quot;).innerHTML=&quot;英雄：&quot; + localStorage.name;]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>sessionStorage</tag>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象]]></title>
    <url>%2F2018%2F02%2F27%2F0809008%2F</url>
    <content type="text"><![CDATA[1. 原始方式： 对象字面量方式 12345var Hero = &#123; name: 'MasterYi', skill: 'AlphaStrike', todo: function () &#123; alert(this.name); &#125;&#125;; Object构造函数方式 12345678910var Hero = new Object();Hero.name = 'MasterYi';Hero.skill = 'Q';Hero.do = function()&#123; return this.name + ' use ' + this.skill + ' kill ' + 'yasuo';&#125;alert( Hero.skill ); // AlphaStrikealert( Hero.do() ); // MasterYi use AlphaStrike kill yasuo 如上，当我们要创建批量的Hero1、Hero2……时，每次都要敲很多代码，资深copypaster都吃不消！然后就有了下面批量生产的工厂模式。 2. 工厂模式12345678910111213141516function heroObj(name, skill)&#123; var Hero = new Object(); Hero.name = name; Hero.skill = skill; Hero.do = function()&#123; return this.name + ' use ' + this.skill + ' kill ' + 'MasterYi'; &#125; return Hero;&#125;var riven = heroObj('yasuo', 'R');var ashe = heroObj('Caitlin', 'W');alert(riven.skill); // Ralert(ashe.do()); // Caitlin use W kill MasterYi 工厂模式就是批量化生产，简单调用就可以进入造人模式（啪啪啪……）。指定姓名年龄就可以造一堆小宝宝啦，解放双手。但是由于是工厂暗箱操作的，所以你不能识别这个对象到底是什么类型、是人还是狗傻傻分不清（instanceof 测试为 Object），另外每次造人时都要创建一个独立的temp对象，代码臃肿，你受得了？ 3. 构造函数123456789101112131415function HeroObj(name, skill)&#123; this.name = name; this.skill = skill; this.do = function()&#123; return this.name + ' use ' + this.skill + ' kill ' + 'MasterYi'; &#125;&#125;var riven = new heroObj('yasuo', 'R');var ashe = new heroObj('Caitlin', 'W');alert(riven.skill); // Ralert(ashe.do()); // Caitlin use W kill MasterYi ECMAScript中的构造函数可以用来创建特定类型的对象。像Object和Array的原生的构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。 4. 原型模式 直接使用 prototype 属性 1234function Hero () &#123;&#125;Hero.prototype.name = 'MasterYi';Hero.prototype.skill = 'AlphaStrike';Hero.prototype.do = function () &#123; alert(this.name); &#125;; 字面量定义方式 12345678function Hero () &#123;&#125;Hero.prototype = &#123; name: 'MasterYi', skill: 'AlphaStrike', sayName: function () &#123; alert(this.name); &#125;&#125;;var p1 = new Hero(); //name='MasterYi'var p2 = new Hero(); //name='MasterYi' 这里需要注意的是原型属性和方法的共享，即所有实例中都只是引用原型中的属性方法，任何一个地方产生的改动会引起其他实例的变化。 5. 混合模式123456789101112131415161718function Hero (name, skill) &#123; this.name = name; this.skill = skill;&#125;Hero.prototype = &#123; skillLists: ['Q', 'W', 'E', 'R']; sayName: function () &#123; alert(this.name); &#125;, do: function () &#123; alert(this.name + ' use ' + this.skill + ' kill ' + 'MasterYi'); &#125;&#125;;var p1 = new Hero('yasuo', 'R');var p2 = new Hero('ashe', 'w');p1.sayName(); // yasuop1.skillLists; // ['Q', 'W', 'E', 'R']p2.do(); // ashe use w kill MasterYi 6. 使用class关键字123456789101112131415161718192021class Hero &#123; constructor()&#123; this.name = 'MasterYi'; this.skill = 'AlphaStrike'; &#125; do(enemy)&#123; alert(this.name + ' use ' + this.skill + ' kill ' + enemy) &#125;&#125;let ashe = new Hero();ashe.do('ashe'); // MasterYi use AlphaStrike kill asheclass Yasuo extends Hero &#123; constructor()&#123; super() this.name = 'yasuo' &#125;&#125;let yasuo = new Yasuo();yasuo.do('timor'); // yasuo use AlphaStrike kill timor 这里涉及到 ES6 里的新特性，想了解 ES6 中更多的新特性，大家可以去看看 阮一峰 老师的博客。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于javascript数组的一些思考]]></title>
    <url>%2F2018%2F02%2F27%2F0809006%2F</url>
    <content type="text"><![CDATA[关于数组的一些认识 使用构造器函数创建数组时:1let ary = new Array(); 若参数只有一个，且为数字，let ary1 = new Array(3)，这是其实我们是在指定数组的长度的，即 ary1.length === 3。ary1[0]则为undefined; 当定义let ary2 = new Array(1, 2, 3)时，此时ary2 === [1, 2, 3]; JS中的数组定义非常的自由：看下面的例子： 1234let ary = [1, 2, 3];ary[5] = 5;console.log(ary); // [1,2,3,undefined,undefined,5]console.log(ary.length); // 6 再看： 123let ary2 = [1, 2, 3, 4, 5];ary2.length = 3;console.log(ary2); // [1, 2, 3] 常用的数组API 万能方法 splice() splice()方法允许我们对数组进行插入、替换和删除的功能。splice方法返回一个有删除元素组成的新数组，没有删除时则返回一个空数组，简直完美呀！ splice()方法接受三个参数，第一个为开始索引，第二个为删除元素的位置，第三个为插入的元素，可以为第二个，当然也可省略（表示删除元素）。 splice()方法会修改原数组！ 通过以下三个demo了解一下具体的用法吧：插入:1234let ary1 = ["first", "second", "third", "forth", "fifth"];let ary2 = ary1.splice(1,0,"add1");console.log(ary1); [ 'first', 'add1', 'second', 'third', 'forth', 'fifth' ]console.log(ary2); [] 没有删除则放回一个空数组 替换：1234let ary1 = ["first", "second", "third", "forth", "fifth"];let ary2 = ary1.splice(1,1,"replace");console.log(ary1); [ 'first', "replace, 'third', 'forth', 'fifth' ]console.log(ary2); ["second"] 返回被删除(即替换)的数组 删除：1234let ary1 = ["first", "second", "third", "forth", "fifth"];let ary2 = ary1.splice(1,3);console.log(ary1); ["second", "third", "forth"]console.log(ary2); ["first", "fifth"] slice() 方法 slice() 方法可以接受两个参数(start, end)； slice() 方法可从已有的数组中返回选定的元素； slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分； slice() 方法不会改变原始数组，而是返回一个新数组。demo1:12345let ary = ["first", "second", "third", "forth", "fifth"];console.log (ary.slice(1,2) ); // ["second"]let ary1 = ary.slice(1,2); // ["second"]let ary2 = ary.slice(1,3); // ["second", "third"]console.log(ary); // ["first", "second", "third", "forth", "fifth"]; demo2:1234let ary = ["first", "second", "third", "forth", "fifth"];console.log(ary.slice(1,2)); // ["second"]console.log(ary.slice(1,3)); // ["second", "third"]console.log(ary)); // ["first", "second", "third", "forth", "fifth"]; demo3:1234567let ary = ["first", "second", "third", "forth", "fifth"];let ary1 = ary.slice(); // ["first", "second", "third", "forth", "fifth"];let ary2 = ary.slice(0); // ["first", "second", "third", "forth", "fifth"];ary === ary1; // falseary === ary2; // falseary1 === ary2; // false 看出来啥猫腻没，这不是深复制一个数据吗！]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F11%2F0809000%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2017%2F02%2F09%2F0809001%2F</url>
    <content type="text"></content>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
